# 클래스

## 목차

- 클래스는 프로토타입의 문법적 설탕인가?
- 클래스의 정의
- 클래스 호이스팅
- 인스턴스 생성
- 메서드
  - constructor
  - 프로토타입 메서드
  - 정적 메서드
  - 정적 메서드와 프로토타입 메서드 차이
  - 클래스에서 정의한 메서드의 특징
- 클래스의 인스턴스 생성 과정
- 프로퍼티
  - 인스턴스 프로퍼티
  - 접근자 프로퍼티
  - 클래스 필드 정의 제안
  - private 필드 정의 제안
  - static 필드 정의 제안
- 상속에 의한 클래스 확장
  - 클래스 상속과 생성자 함수 상속
  - extends 키워드
  - 동적 상속
  - 서브클래스의 constructor
  - super 키워드
  - 상속클래스의 인스턴스 생성과정
  - 표준 빌트인 생성자 함수 확장

<br>
<br>

## 클래스는 프로토타입의 문법적 설탕인가?

<br>

> 문법적 설탕?
>
> Syntac Sugar라고 불리며 한국어로 "문법 설탕"이라고 번역되고,
> 읽는 사람, 작성하는 사람이 편하게 디자인된 문법이라고 설명된다.
>
> 번거롭게 작성되었던 코드들이 짧아지는 경험을 할 수 있고 가독성도 좋아지는 효과가 있다.

왜 이런 이야기가 나왔을까?

그것은 바로 "자바스크립트는 프로토타입 기반 객체지향을 지원하는 언어"이기 때문이라고 생각한다.

우선 Class가 등장하기전 ES5에서도 생성자함수와 프로토타입을 사용하여 객체지향 언어의 상속을 구현할 수 있었다.

```js
// ES5 생성자 함수
var Person = (function () {
  // 생성자 함수
  function Person(name) {
    this.name = name;
  }

  // 프로토타입 메서드
  Person.prototype.sayHi = function () {
    console.log("Hi! My name is " + this.name);
  };

  // 생성자 함수 반환
  return Person;
})();

// 인스턴스 생성
var me = new Person("Lee");
me.sayHi(); // Hi! My name is Lee
```

이 책에서는 프로토타입 기반 프로그래밍은 클래스 기반의 개발자들에게 혼란을 야기하기도 하였고 어려움중에 하나여서 도입되었다고 설명한다.

이 Class가 도입되었다고해서 기존의 JavaScript의 프로토타입 기반의 객체지향 모델을 폐지하는 것은 아니다.

JS에서의 클래스는 사실상 함수이고, 기존의 프로토타입 기반 패턴을 **클래스 기반 패턴처럼 사용할 수 있게끔 해주기에 문법적 설탕**이라고 말할 수 있다는 것이다.

또한 클래스, 생성자 함수 둘 다 프로토 타입 기반으의 인스턴스를 생성하지만 동작은 일치하지 않는다. 밑의 표를 참고하자.

- 클래스를 new 연산자 없이 호출하면 에러, 생성자 함수는 new 연산자 없이 후출하면 일반 함수로써 호출
- 클래스는 상속을 지원하는 extends, super키워드를 제공, 생성자 함수는 없다.
- 클래스는 호이스팅이 **발생하지 않는 것 처럼** 동작, 생성자 함수는 함수 선언문으로 정의된 함수는 호이스팅, 표현식으로 작성한 생성자함수는 "변수 호이스팅"이 발생
- 클래스 내 모든 코드는 strict mode가 지정됨 해제도 불가능, 생성자 함수는 암묵적으로 strict mode가 지정되지 않는다.
- 클래스는 constructor, 프로토타입 메서드, 정적 메서드로 모두 어트리뷰트가 [[Enumerable]]의 값이 false로 열거되지 않는다.

클래스에서 사용되는 객체 생성 방식은 기존 프로토타입 기반보다 훨씬 명료하며, extends super와 같은 상속관계 구현을 해주는 키워드도 간결하고 명확하다.

이 책에서는 클래스를 단순한 문법적 설탕이라고 보기보다는 **새로운 객체 생성 매커니즘**이라고 말하고 있다.

<br>

나의 의견

외부적으로는 class로 작성하지만 내부적인 동작 방식은 프로토타입 기반으로 구성되어 있기에 "편의 문법"이라고 불리는 것이 맞다고 생각한다.

나의 며칠동안의 고민은 애초에 프로토타입으로 동작 중인 JavaScript언어를 Class로 작성을 하여 한번 더 해석을 해서 바꿀 필요가 있을까? 라는 생각과 JavaScript코드를 구경하다보면 class기반으로 작성된 코드들이 많이 있는데 이것이 과연 JavaScript를 제대로 활용하고 있는 방법인가? 라는 의문도 든다.

나 스스로 정의를 내려서 이후 코드를 작성하고 싶기에 이 파트는 정말로 신중하게 공부해보겠다.

<br>


## 클래스 정의

<br>

자바스크립트의 클래스는 class키워드로 정의한다.

생성자 함수와 마찬가지로 파스칼 케이스를 사용한다.

```js
class Person{}
```
<br>
class도 마찬가지로 표현식으로 정의가 가능하다.

```js
// 익명 클래스 표현식
const Person = class {};

// 기명 클래스 표현식
const Person = class MyClass {};
```

<br>
표현식으로 정의 할 수 있다라는 말은 클래스가 값으로 사용이 가능하다. 고로 클래스는 "일급객체"이다 라는 것을 의미합니다.

더 자세히 말하자면 JavaScript에서의 **클래스는 함수**입니다. 고로 클래스는 "일급객체"입니다.

> 일급객체가 가지는 특징
>
>  - 무명의 리터럴로 생성 가능하다. -> 런타임에 생성이 가능하다.
>  - 변수나 자료구조에 저장이 가능하다.
>  - 함수의 매개변수에 전달이 가능하다.
>  - 함수의 반환값(return)으로 사용이 가능하다.

<br>

클래스 몸체에는 0개 이상의 메서드만 정의할 수 있습니다.

클래스 몸체에는 **constructor(생성자), 프로토타입 메서드, 정적메서드 ** 가 있습니다.

```js
// 클래스 선언문
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name; // name 프로퍼티는 public하다.
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi! My name is ${this.name}`);
  }

  // 정적 메서드
  static sayHello() {
    console.log('Hello!');
  }
}

// 인스턴스 생성
const me = new Person('nara');

// 인스턴스의 프로퍼티 참조
console.log(me.name); // nara
// 프로토타입 메서드 호출
me.sayHi(); // Hi! My name is Lnara
// 정적 메서드 호출
Person.sayHello(); // Hello!****
```

<br>

## 클래스 호이스팅

<br>

JavaScript에서의 클래스는 함수로 평가됩니다.

```js
class Person{}

console.log(typeof Person) // function
```