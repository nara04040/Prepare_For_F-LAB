# 재귀에 대한 실행컨텍스트와 스택

재귀란 어떤 것인지 알게되었으니 실제로 재귀를 호출할때 어떤 동작이 일어나는지 알아보자.

우선 함수의 내부 동작에 대하여 살펴보자.

실행중인 함수의 실행 절차의 정보는 해당 함수의 **"실행 컨텍스트"** 에 저장된다.

>실행 컨텍스트란?
>> 함수 실행에 대한 세부정보를 담고 있는 내부 데이터 구조.
>> 
>> 제어흐름의 현재 위치, 변수의 현재 값, this의 값 등 내부 정보가 실행 컨텍스트에 저장된다.

함수 호출 1회당 정확히 하나의 실행 컨텍스트가 실행된다.

만약 함수 내부에서 중첩 호출이 있을 때는 아래와 같은 절차가 수행된다.
- 현재 함수의 실행이 일시 중지.
- 중지된 함수와 연관된 실행 컨텍스트는 **실행 컨텍스트 스택** 이라는 특별한 자료 구조에 저장된다.
- 중첩 호출이 실행
- 중첩 호출이 실행 끝난 이후 실행 컨텍스트 스택에서 중단한 함수의 실행 컨텍스트를 꺼내고, 중단된 실행을 다시 시작한다.


자 그렇다면 이전의 pow(2,3)함수를 호출한다면 실행 컨텍스트는 어떤 일이 일어나는지 알아보자.

### pow(2,3) 호출시 실행컨텍스트 과정

1. pow(2,3)을 호출하는 순간, 실행 컨텍스트에는 변수 x = 2, n = 3이 저장, 실행 흐름은 함수의 첫 번째줄에 위치
> 도식화 : Context : {x : 2, n : 3, 첫 번째줄}
2. 조건이 n === 1에 만족하지 못하기 때문에 실행흐름은 if 두 번째 분기로 넘어간다.

변수는 동일하지만, 실행컨텍스트는 변경된다.

> Context: { x: 2, n: 3, 다섯 번째 줄 } 

3. x * (x, n - 1)을 계산하려면 pow의 서브호출, pow(2,2)을 만들어야 한다.

4. pow(2,2) 자바스크립트는 중첩 호출을 위해 실행 컨텍스트 스택에 현재 실행 컨텍스트를 저장한다.

>Context: { x: 2, n: 2, 첫 번째 줄 } pow(2, 2)
>
>Context: { x: 2, n: 3, 다섯 번째 줄 } pow(2, 3)

pow(2,2)가 최상단에 위치한 이유는 모든 함수는 아래와 프로세스가 적용되기 때문이다.

- 스택 최상단에 현재 컨텍스트가 '기록'된다.
- 서브 호출을 우한 새로운 컨텍스트가 만들어진다.
- 서브 호출이 완료되면, 기존 컨텍스트를 스택에서 꺼내어 실행을 이어간다.

5. pow(2,1)을 실행하기 위해 동일한 과정이 반복.
6. pow(2,1) 실행컨텍스트는 스택 최상단에 (push)올라간다.

>Context: { x: 2, n: 1, 첫 번째 줄 } pow(2, 1)
>
>Context: { x: 2, n: 2, 다섯 번째 줄 } pow(2, 2)
>
>Context: { x: 2, n: 3, 다섯 번째 줄 } pow(2, 3)

7. pow(2,1)가 실행 될때는 상황이 다르다. 조건 n === 1을 만족시키기에 if 첫 번째 분기가 실행된다.
8. 함수는 종료되고 2가 반환.

>Context: { x: 2, n: 2, 다섯 번째 줄 } pow(2, 2)
>
>Context: { x: 2, n: 3, 다섯 번째 줄 } pow(2, 3)

9.pow(2,2)실행이 다시 시작, 4를 반환

>Context: { x: 2, n: 3, 다섯 번째 줄 } pow(2, 3)

10. pow(2,3)이 실행이 다시 시작, 8을 반환

보다싶이 재귀의 깊이는 3이 된다.

하지만 이렇게 n을 늘리면 n개의 실행 컨텍스트가 저장될 메모리 공간이 필요하기 때문에 메모리 절약 측면에서 문제가 될 수 있다.

이때는 반복문 기반 알고리즘을 사용한다면 메모리가 절약된다.

재귀 : 코드가 짧아지고 이해도 상승, 유지보수에 이점. 메모리측면에서 반복문보다 좋지않다.

반복문 : 코드가 길고, 이해도, 유지보수에서 재귀보다 좋지않지만 메모리측면에서는 좋다.


